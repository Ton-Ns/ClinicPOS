# Architecture & Design Decisions

## 1. Primary Branch Model
**Decision**: We model the relationship between a Patient and a Branch using a simple `PrimaryBranchId` field on the `Patient` entity, rather than a many-to-many `PatientBranch` table for this v1 slice.

**Reasoning**:
- **Simplicity**: The requirement "1 Patient belongs to exactly 1 Tenant, and may visit multiple Branches" allows for a primary association. For a v1 "thin slice", tracking the *primary* branch of registration is sufficient for the "List Patients" view.
- **YAGNI (You Ain't Gonna Need It Yet)**: A full visit history or multi-branch registration system adds complexity (join tables, composite keys) that isn't strictly necessary for the core requirement of "Create Patient" and "List Patients".
- **Extensibility**: This does not preclude adding a `Visits` table later which links Patients to Branches for specific appointments. The `PrimaryBranchId` serves as the "home base" for the patient.

## 2. Multi-Tenancy Strategy (E2)
- **Derivation**: 
  - For **External API** calls: Derived from the `X-Tenant-Id` header.
  - For **Authenticated** sessions: Derived from the `TenantId` claim within the user's identity (populated by `StubAuthHandler`).
- **Data Access Layer Enforcement**: 
  - **Read Isolation**: Every entity implementing `ITenantEntity` is subject to a **Global Query Filter** in `ApplicationDbContext`. This filter is automatically injected into the `WHERE` clause of every LINQ query generated by EF Core.
  - **Write Isolation**: The `ApplicationDbContext` overrides `SaveChangesAsync`. Before committing, it scans the change tracker for any `ITenantEntity`. If the `TenantId` is missing, it automatically populates it from the current `ITenantService` context.
- **Prevention of Missing Filters**: 
  - **Interface Constraint**: Every multi-tenant entity *must* implement `ITenantEntity`.
  - **Automatic Registry**: The `OnModelCreating` method dynamically applies the filter to all entities implementing the interface, ensuring no new table can bypass isolation by accidental omission of a manual `Where` clause.

## 3. Section E â€” Domain Events (E1)
### Domain Event: `AppointmentCreated`
- **Emission**: Dispatched from `AppointmentsController` immediately after a successful `SaveChangesAsync()` call.
- **Payload**: Includes `AppointmentId`, `TenantId`, `BranchId`, and `StartAt`.
- **Guarantees**: 
  - **Reliability**: Published using MassTransit. In the currently configured `InMemory` mode, it provides immediate processing. In a RabbitMQ production setup, it provides at-least-once delivery guarantees.
  - **Transaction Boundary**: The event is emitted **out-of-process**. It is sent *after* the database transaction has committed, ensuring we don't notify external systems of appointments that failed to save. For mission-critical consistency, this could be upgraded to an **Outbox Pattern** to ensure the event is saved to the DB and published reliably even if the worker crashes post-commit.

## 4. Technology Stack Alignment
- **.NET 10**: Leveraging latest performance improvements and rigorous type safety.
- **Next.js**: Server Components for efficient data fetching and SEO-friendly rendering.
